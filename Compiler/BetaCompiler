#-----------------------------------------------------------------------------------------------------
#Rules                  : Not very helpful
#-----------------------------------------------------------------------------------------------------
#Lines 1,2: Variables are declare at the top of the program. First unsigned, then signed. 
#           All variables are implicitly of type 8-bit integer. No need to declare that.  
#           Only 3 unsigned variables are allowed: a, b, c.  
#           Only 3 signed variables are allowed: x, y, z. 
#Lines 4-9: One assignment is performed per line. Donâ€™t write b = 0, x = 4 etc 
#Lines 5,6,12,14: The four arithmetic operations allowed are + - * / 
#Line 6: A single line can have max of two arithmetic operations. Operators are evaluated left to right. 
#        For example, Line 6 means c = (b * a) / 10 
#Line 6: Only the integer part of an operation is preserved. So the output of Line 6 right-side is (18*3)/10 = 5 
#Lines 11,16: Two types of conditional structures are allowed: if-else and while loop. No nested structures. 
#Lines 11-21: Indentation indicates whether a line is inside an if-else or a while loop 
#Lines 11,16: Only a single relational operator is allowed in if and while statements. 
#             So if x > 10 && y < 5 is not allowed. 
#Lines 17-21: The print command is the only mechanism to output a value. 
#             There is no user input command, i.e. a cin equivalent 

#-----------------------------------------------------------------------------------------------------
#NOTES:
#-----------------------------------------------------------------------------------------------------
#Were using python and we know what variables are signed and unsigned, so just make differnt if statments

#Should output 2 txt files (Assembly and Machine code): Or just one that seperates them

#Indentation should be checked for the high level code to determine if in if/while loops

#If a varible was signed or unsigned. Would i need to have a manual check for if its outside of that number range so that it gives an error message?




#there is one in both the betaCompiler and Assmebly-to-Machine file. One must go

#oldCode can go, just temp holder

#Finish unsigned and signed in both betaCompiler and Assembly-to-Machine

#Add the print command to the assembly conversion

#------------------------------------------------------------------
#Storage Management for Assembly
#------------------------------------------------------------------
stackCounter = 0

class Stack:
    def __init__(self):
        self.stack = [] #blank array to represent

    def push(self, register):
        stackCounter = stackCounter + 1 #To know where things located
        self.stack.append(register)

    def pop(self):
        stackCounter = stackCounter - 1 #To know where things are located
        if len(self.stack) < 1:
            return None
        return self.stack.pop()

#How it works:

#create a stack
    #stack = Stack() 

#Push registers to the stack
    #stack.push('eax')
    #stack.push('ebx')
    #stack.push('ecx')

#How to Pop registers from the stack (just an example)
    #print(stack.pop())  # Outputs: %ecx
    #print(stack.pop())  # Outputs: %ebx
    #print(stack.pop())  # Outputs: %eax



#Memory:
    #eax = 0001
    #ebx = 0002
    #ecx = 0003
    #edx = 0004
    #a = 0005
    #b = 0006
    #c = 0007
    #x = 0008
    #y = 0009
    #z = 0010
    #line 0 = 0011 -> Increments up for storage
#-----------------------------------------------------------------------------------------------------
#flags
#-----------------------------------------------------------------------------------------------------
#make a function to be ran after each step for the flags to be updated
#reset at beginning of function, output to csv file
#maybe make seperate file
overflowF = 0
zeroF = 0
carryF = 0
signF = 0

#-----------------------------------------------------
#writeASM fucntion (for HLC to ASM)
#-----------------------------------------------------
def writeASM (lineCounter, new_line):
    line_number = lineCounter  # The line numbers are 1-based
    #new_line = 'This is the new text for line 3\n'

    # Read all lines
    with open('assembler.txt', 'r') as f:
        lines = f.readlines()

    # Modify the specific line
    if line_number - 1 < len(lines):
        lines[line_number - 1] = new_line
    else:
        lines.append(new_line)  # Append the new line if the file has fewer lines

    # Write all lines back to the file
    with open('assembler.txt', 'w') as f:
        f.writelines(lines)

    return 0

#-----------------------------------------------------------------------------------------------------
#variables/imports
#-----------------------------------------------------------------------------------------------------
import re

i = 0
lineCounter = 0

#preload before program just in case
a = 0
b = 0
c = 0
x = 0
y = 0
z = 0

#registers
eax = 0
ebx = 0
ecx = 0
edx = 0

#placeHolder registers
eax2 = 0
ebx2 = 0
ecx2 = 0
edx2 = 0


#-----------------------------------------------------------------------------------------------------
#register updates
#-----------------------------------------------------------------------------------------------------
#stores its own backup registers after each line and compares. if something was changed, it will show on the csv file

def regCheck (eax, ebx, ecx, edx):
    regChanges = None   #reset before check

    if (eax != eax2):
       regChanges = regChanges + ', eax'
    if (ebx != ebx2):
       regChanges = regChanges + ', ebx'
    if (ecx != ecx2):
       regChanges = regChanges + ', ecx'
    if (edx != edx2):
       regChanges = regChanges + ', edx'
    
    return regChanges

#-----------------------------------------------------------------------------------------------------
#parser
#-----------------------------------------------------------------------------------------------------

def betaParser (i):
    lineCounter = lineCounter + 1   #increments for each line, there is one in both the betaCompiler and Assmebly-to-Machine file. One must go or they should be different
    temp = len(placeHolder)

    with open('test.txt', 'r') as file:
        content = file.readlines()#reads all lines
        line2 = content[i] #gets line
        placeHolder = re.split('[ ]', line2)  #splits line into words : just a space, this is meant more for more than one split type though

    if (placeHolder[0] == "unsigned"):  #the varibles are consisnt with naming right?
        writeASM(lineCounter, 'finsh unsigned')       #FINISH Unsigned
    elif (placeHolder[0] == "signed"):
        writeASM(lineCounter, 'finish signed')      #FINSH Signed
    elif (placeHolder[0] == "a" or "b" or "c"): #only positive range: 0 to 255
        #check lenght to figure out whats happening
        #3 = declaration, 5 = regular arithmetic, 7 = double arithmetic
        
        #everything happens in here, the compiler

        if (temp == 3): #basic declaration
            #can have variabes, to move in and out of memory
            if (placeHolder[0] == 'a'):
                var1 = 'a'
                if (placeHolder[2] == 'a'):
                    #basically a noop : registers stay the same and nothing happens
                    var2 = 'a' 
                    
                    eax = a
                    a = eax

                elif (placeHolder[2] == 'b'):
                    var2 = 'b' 
                    
                    eax = b
                    a = eax

                elif (placeHolder[2] == 'c'):
                    var2 = 'c' 
                    
                    eax = c
                    a = eax

                elif (placeHolder[2] == 'eax'):
                    var2 = 'eax' 
                    a = eax  
                                  
                elif (placeHolder[2] == 'ebx'):
                    var2 = 'ebx' 
                    a = ebx  

                elif (placeHolder[2] == 'ecx'):
                    var2 = 'ecx' 
                    a = ecx  

                elif (placeHolder[2] == 'edx'):
                    var2 = 'edx' 
                    a = edx  
                else:   #moving a specified number into the memory
                    var2 = placeHolder[2]
                    a = placeHolder[2]

            elif (placeHolder[0] == 'b'):
                var1 = 'b'
                if (placeHolder[2] == 'a'):
                    #basically a noop : registers stay the same and nothing happens
                    var2 = 'a' 
                    
                    eax = a
                    b = eax

                elif (placeHolder[2] == 'b'):
                    var2 = 'b' 
                    
                    eax = b
                    b = eax

                elif (placeHolder[2] == 'c'):
                    var2 = 'c' 
                    
                    eax = c
                    b = eax

                elif (placeHolder[2] == 'eax'):
                    var2 = 'eax' 
                    b = eax  
                                  
                elif (placeHolder[2] == 'ebx'):
                    var2 = 'ebx' 
                    b = ebx  

                elif (placeHolder[2] == 'ecx'):
                    var2 = 'ecx' 
                    b = ecx  

                elif (placeHolder[2] == 'edx'):
                    var2 = 'edx' 
                    a = edx  
                else:   #moving a specified number into the memory
                    var2 = placeHolder[2]
                    b = placeHolder[2]

            elif (placeHolder[0] == 'c'):
                var1 = 'c'
                if (placeHolder[2] == 'a'):
                    #basically a noop : registers stay the same and nothing happens
                    var2 = 'a' 
                    
                    eax = a
                    c = eax

                elif (placeHolder[2] == 'b'):
                    var2 = 'b' 
                    
                    eax = b
                    c = eax

                elif (placeHolder[2] == 'c'):
                    var2 = 'c' 
                    
                    eax = c
                    c = eax

                elif (placeHolder[2] == 'eax'):
                    var2 = 'eax' 
                    c = eax  
                                  
                elif (placeHolder[2] == 'ebx'):
                    var2 = 'ebx' 
                    c = ebx  

                elif (placeHolder[2] == 'ecx'):
                    var2 = 'ecx' 
                    c = ecx  

                elif (placeHolder[2] == 'edx'):
                    var2 = 'edx' 
                    c = edx  
                else:   #moving a specified number into the memory
                    var2 = placeHolder[2]
                    c = placeHolder[2]
                    

            elif (placeHolder[0] == 'eax'):
                var1 = 'eax'
                
            elif (placeHolder[0] == 'ebx'):
                var1 = 'ebx'

            elif (placeHolder[0] == 'ecx'):
                var1 = 'ecx'

            elif (placeHolder[0] == 'edx'):
                var1 = 'edx'

            else:
                var1 = placeHolder[0]
                #need an if statement to check for other



            var4 = 'mov ' + var1 + ', ' + var2
            writeASM(lineCounter, var4)


            #temp 5 will have t0 change
        elif (temp == 5): #basic math : 0 1 2 3 4 : y = a + b
            if (placeHolder[3] == "+"):
                var4 = 'add ' + placeHolder[0] + placeHolder[2] + placeHolder[4]
                writeASM(lineCounter, var4)

            elif (placeHolder[3] == "-"):
                var4 = 'sub ' + placeHolder[0] + placeHolder[2] + placeHolder[4]
                writeASM(lineCounter, var4)

            elif (placeHolder[3] == "*"):
                var4 = 'mult ' + placeHolder[0] + placeHolder[2] + placeHolder[4]
                writeASM(lineCounter, var4) 

            elif (placeHolder[3] == "/"):
                var4 = 'div ' + placeHolder[0] + placeHolder[2] + placeHolder[4]
                writeASM(lineCounter, var4)

            else:
                print("Compiler: Something happened at temp 5 in abc")
        elif (temp == 7): #2 types for the math
                #can just do a 'mult' + 'div' = 'multdiv'
        else:
            print("Error in the compiler: Length is not right")

    elif (placeHolder[0] == "x" or "y" or "z"): #both positive and negative     Range: -128 to 127

    elif (placeHolder[0] == "if"):
        #worry about indentation

    elif (placeHolder[0] == "else"):
        #worry about indentation

    elif (placeHolder[0] == "while"):
        #worry about indentation
    
    else:
        print("Error for Parser")



    return 0




#---------------------------------------------------------------------
#What actually does assembly work stuff (This is where things are dont, like arithmetics and moving into or from memory)
#---------------------------------------------------------------------



#---------------------------------------------------------------------
#Start to run stuff
#---------------------------------------------------------------------

i = 0   #Define  i, which is correspondent to line #

while (i >= 21):    #i = line number currently on
    betaParser(i)   #Parse line
                    #Function to conver to assembly, also prints conversion to text file
                    #Converts ASM to Machine Code (Just a loop to check each assembly line conversion and printing to seperate text file)

    #make csv file in here, line by line
    

  


    i = i + 1   #Loop ends here and restarts


