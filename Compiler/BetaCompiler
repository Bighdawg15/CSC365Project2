#-----------------------------------------------------------------------------------------------------
#Rules                  : Not very helpful
#-----------------------------------------------------------------------------------------------------
#Lines 1,2: Variables are declare at the top of the program. First unsigned, then signed. 
#           All variables are implicitly of type 8-bit integer. No need to declare that.  
#           Only 3 unsigned variables are allowed: a, b, c.  
#           Only 3 signed variables are allowed: x, y, z. 
#Lines 4-9: One assignment is performed per line. Donâ€™t write b = 0, x = 4 etc 
#Lines 5,6,12,14: The four arithmetic operations allowed are + - * / 
#Line 6: A single line can have max of two arithmetic operations. Operators are evaluated left to right. 
#        For example, Line 6 means c = (b * a) / 10 
#Line 6: Only the integer part of an operation is preserved. So the output of Line 6 right-side is (18*3)/10 = 5 
#Lines 11,16: Two types of conditional structures are allowed: if-else and while loop. No nested structures. 
#Lines 11-21: Indentation indicates whether a line is inside an if-else or a while loop 
#Lines 11,16: Only a single relational operator is allowed in if and while statements. 
#             So if x > 10 && y < 5 is not allowed. 
#Lines 17-21: The print command is the only mechanism to output a value. 
#             There is no user input command, i.e. a cin equivalent 

#-----------------------------------------------------------------------------------------------------
#NOTES:
#-----------------------------------------------------------------------------------------------------
#Were using python and we know what variables are signed and unsigned, so just make differnt if statments

#Should output 2 txt files (Assembly and Machine code): Or just one that seperates them

#Indentation should be checked for the high level code to determine if in if/while loops

#If a varible was signed or unsigned. Would i need to have a manual check for if its outside of that number range so that it gives an error message?






#-----------------------------------------------------------------------------------------------------
#Is their somesort of start at beginning of compiler to initialize?


with open('file.txt') as file_object:   #Something to open the textfile
    contents = file_object.read()
    print(contents)

#Search the textfile for certain things


#----------------------------------------------------------------------------------------
#only searchs for 1 operation
def parse_line(line):
    operators = ['=', '+', '-', '/', '<=', '>='] #Defines for different operators : Doesn;t need <= or >=
    
    #Initialize the operands and operator; kinda interesting how you can use none?
    operand1 = operand2 = operator = None           
    
    #Check's for each operator
    for op in operators:
        if op in line:
            #Split line into parts
            parts = line.split(op)
            
            #Get the var_name ; strip removes leading/trailing whitespace
            var_name = parts[0].strip()
            
            #Get the expression, split it into operands
            expression = parts[1].strip()
            operands = expression.split(' ')
            
            #Convert the operands to integers and store
            operand1 = int(operands[0].strip())
            if len(operands) > 1:
                operand2 = int(operands[1].strip())
            
            operator = op
            break
    
    return var_name, operator, operand1, operand2

#Test Function?
#line = "y = 10 + 4"        #I'd set variable after storing line then run function
#var_name, operator, operand1, operand2 = parse_line(line)
#print(f"Variable: {var_name}, Operator: {operator}, Operand1: {operand1}, Operand2: {operand2}")

#-----------------------------------------------------------------------------------------------------
#
#-----------------------------------------------------------------------------------------------------
#Make if statment to check line #, that will determine what we do
#


# Open file
file = open('test.txt') 
  
# read the content of the file opened 
content = file.readlines() 
print(content[i]) #Prints contents from line 10 : Line 1 is 0 in this scale



# print first 3 lines of file 
#print("first three lines") 
#print(content[0:3]) 

ops = {'+', '-', '*', '/', '='}

def parser (i): # Starts at line 0
    #insert loop so that this repeats, or place outside of function
    counter = None #Resets for the beginning of function
    
    #Counts number of arithmatic

    #do I need to use the placeholder varible for this? If so use a loop to route through all the components
    counter = content[i].count('+')
    counter = content[i].count('-')
    counter = content[i].count('*')
    counter = content[i].count('/')
    counter = content[i].count('=')

    placeHolder = content[i].split()    #splits specific line 

    if (counter == 0):
        #Only checks for signed or unsigned
        #also checks if space is blank
        if (placeHolder[0] == "unsigned"):
            #Output Unsigned to assembly
        elif (placeHolder[0] == "signed"):
            #Output Signed to assembly
        elif (placeHolder[0] == ""):
            #return blank space
        else:
            #Error Handling message

    elif (counter == 1):   #Means this is a loop of somesort, or just basic declaration
        #Check for while of if
        #or ex. B = 4 ; Pretty simple
        if (placeHolder[0] == "while"):
            #
        elif (placeHolder[0] == "if"):
            #
        elif (placeHolder[0] == "a"):
            #store number into designated slot of memory 
        elif (placeHolder[0] == "b"):
            #store number into designated slot of memory 
        elif (placeHolder[0] == "c"):
            #store number into designated slot of memory 
        elif (placeHolder[0] == "x"):
            #store number into designated slot of memory 
        elif (placeHolder[0] == "y"):
            #store number into designated slot of memory 
        elif (placeHolder[0] == "z"):
            #store number into designated slot of memory 
        else:
            #Error Handling

    elif (counter == 2): #Somesort of arithmatic. Ex. y = x + z
        #If the arithmatic is only 2
        #Split y = x + y
        #I know the format, so just check that specific spot
        if (placeHolder[4] == "+"):
            #
            if (placeHolder[0] == "a"): #check which variable it is
                #
                a = placeHolder[3] + placeHolder[5]
            elif (placeHolder[0] == "b"):
                #
                b = placeHolder[3] + placeHolder[5]
            elif (placeHolder[0] == "c"):
                #
                c = placeHolder[3] + placeHolder[5]
            elif (placeHolder[0] == "x"):
                #
                x = placeHolder[3] + placeHolder[5]
            elif (placeHolder[0] == "y"):
                #
                y = placeHolder[3] + placeHolder[5]
            elif (placeHolder[0] == "z"):
                #
                z = placeHolder[3] + placeHolder[5]
            else:
                #Error Handling     

        elif (placeHolder[3] == "-"):
            #
            if (placeHolder[0] == "a"): #check which variable it is
                #
                a = placeHolder[3] - placeHolder[5]
            elif (placeHolder[0] == "b"):
                #
                b = placeHolder[3] - placeHolder[5]
            elif (placeHolder[0] == "c"):
                #
                c = placeHolder[3] - placeHolder[5]
            elif (placeHolder[0] == "x"):
                #
                x = placeHolder[3] - placeHolder[5]
            elif (placeHolder[0] == "y"):
                #
                y = placeHolder[3] - placeHolder[5]
            elif (placeHolder[0] == "z"):
                #
                z = placeHolder[3] - placeHolder[5]
            else:
                #Error Handling        
            
        elif (placeHolder[3] == "*"):
            #
            if (placeHolder[0] == "a"): #check which variable it is
                #
                a = placeHolder[3] * placeHolder[5]
            elif (placeHolder[0] == "b"):
                #
                b = placeHolder[3] * placeHolder[5]
            elif (placeHolder[0] == "c"):
                #
                c = placeHolder[3] * placeHolder[5]
            elif (placeHolder[0] == "x"):
                #
                x = placeHolder[3] * placeHolder[5]
            elif (placeHolder[0] == "y"):
                #
                y = placeHolder[3] * placeHolder[5]
            elif (placeHolder[0] == "z"):
                #
                z = placeHolder[3] * placeHolder[5]
            else:
                #Error Handling          
            
        elif (placeHolder[3] == "/"):
            #
            if (placeHolder[0] == "a"): #check which variable it is
                #
                a = placeHolder[3] / placeHolder[5]
            elif (placeHolder[0] == "b"):
                #
                b = placeHolder[3] / placeHolder[5]
            elif (placeHolder[0] == "c"):
                #
                c = placeHolder[3] / placeHolder[5]
            elif (placeHolder[0] == "x"):
                #
                x = placeHolder[3] / placeHolder[5]
            elif (placeHolder[0] == "y"):
                #
                y = placeHolder[3] / placeHolder[5]
            elif (placeHolder[0] == "z"):
                #
                z = placeHolder[3] / placeHolder[5]
            else:
                #Error Handling        
                        
        else:
            #Error handling message

    elif (counter == 3): # For Equations like y = x + z + a
        #
        if (placeHolder[0] == "a"):
            #
            if (placeHolder[4] == ""):
            #
        elif (placeHolder[0] == "b"):
            #
        elif (placeHolder[0] == "c"):
            #
        elif (placeHolder[0] == "x"):
            #
        elif (placeHolder[0] == "y"):
            #
        elif (placeHolder[0] == "z"):
            #
    else:    
        #Display error message
        placeholder = None
    return 0 #list variables to return


#Check's for which operator was use, and how many : Might need to put under 1 varibale to check if I'm limited to variables

i = 0   #Define  i, which is correspondent to line #

while (i >= 21):    #i = line number currently on
    parser(i)   #Parse line
                #Function to conver to assembly, also prints conversion to text file
                #Converts ASM to Machine Code (Just a loop to check each assembly line conversion and printing to seperate text file)


    

  


    i = i + 1   #Loop ends here and restarts


#------------------------------------------------------------------
#Storage Management for Assembly
#------------------------------------------------------------------
#push and pop will be enacted by a array for each register, or for the memory (Still deciding)

mCount = 0
var = {0, 0, 0, 0, 0, 0} #Would need to make it bigger to make it represent memory or push/pop

#ex.
    def push(var):  #Change var to whatever needs to be input
        
        var.append(var) # (Is whats being added to the array)
        var[mCount] = 55 #Modify specific thing in array

        mCount = mCount + 1 #increment through memory
        return var[i] #Return variable

    def pop(var): #Pull things out of the memory
           


        return